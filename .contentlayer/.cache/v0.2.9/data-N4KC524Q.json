{
  "cacheItemsMap": {
    "using-memo-and-useMemo-to-optimize-useContext-in-React.md": {
      "document": {
        "title": "React中利用memo和useMemo优化useContext值的渲染",
        "date": "2022-08-25T00:00:00.000Z",
        "slug": "using-memo-and-useMemo-to-optimize-useContext-in-React",
        "tags": [
          "React",
          "React Hooks"
        ],
        "category": "Tec",
        "body": {
          "raw": "\r\n## useContext 的重新渲染问题\r\n\r\n在 React 中如果使用`useContext`hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，`AppContext`提供了两个 value: `count`和`price`，两个子组件`CountChild`和`PriceChild`分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。\r\n\r\n而期望的结果是：当 count 刚更新时，只有`CountChild`重新渲染，price 值同理。\r\n\r\n```jsx\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    <AppContext.Provider value={{ count, price }}>\r\n      <div className=\"App\">\r\n        <button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        </button>\r\n\r\n        <button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        </button>\r\n\r\n        <div>count: {count}</div>\r\n        <div>price: {price}</div>\r\n\r\n        <CountChild />\r\n        <PriceChild />\r\n      </div>\r\n    </AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\r\n```\r\n\r\n## 解决方案\r\n\r\nhttps://github.com/facebook/react/issues/15156\r\n\r\n在 React 的该 issue 中，官方提供了三种解决方案：\r\n\r\n1. 分割 context: （官方推荐）\r\n\r\n在上例中，即将`AppContext`分割成`CountContext`和`PriceContext`提供给相应子组件使用。该方案较简单，不再赘述。\r\n\r\n2. 利用`memo`api\r\n\r\n将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。\r\n\r\n```jsx\r\nconst CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return <CountChild count={count} />\r\n}\r\n```\r\n\r\n3. 利用`useMemo` hooks\r\n\r\n一个组件内部使用`useMemo`，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。\r\n\r\n```jsx\r\nconst MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      <div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      </div>\r\n    )\r\n  }, [price])\r\n}\r\n```\r\n\r\n## Full Code\r\n\r\n<iframe src=\"https://stackblitz.com/edit/react-h3dmvb?embed=1&file=src/App.js\" width=\"100%\" height=\"400px\"></iframe>\r\n",
          "html": "<h2>useContext 的重新渲染问题</h2>\n<p>在 React 中如果使用<code>useContext</code>hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，<code>AppContext</code>提供了两个 value: <code>count</code>和<code>price</code>，两个子组件<code>CountChild</code>和<code>PriceChild</code>分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。</p>\n<p>而期望的结果是：当 count 刚更新时，只有<code>CountChild</code>重新渲染，price 值同理。</p>\n<pre><code class=\"language-jsx\">import React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    &#x3C;AppContext.Provider value={{ count, price }}>\r\n      &#x3C;div className=\"App\">\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        &#x3C;/button>\r\n\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        &#x3C;/button>\r\n\r\n        &#x3C;div>count: {count}&#x3C;/div>\r\n        &#x3C;div>price: {price}&#x3C;/div>\r\n\r\n        &#x3C;CountChild />\r\n        &#x3C;PriceChild />\r\n      &#x3C;/div>\r\n    &#x3C;/AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\n</code></pre>\n<h2>解决方案</h2>\n<p>https://github.com/facebook/react/issues/15156</p>\n<p>在 React 的该 issue 中，官方提供了三种解决方案：</p>\n<ol>\n<li>分割 context: （官方推荐）</li>\n</ol>\n<p>在上例中，即将<code>AppContext</code>分割成<code>CountContext</code>和<code>PriceContext</code>提供给相应子组件使用。该方案较简单，不再赘述。</p>\n<ol start=\"2\">\n<li>利用<code>memo</code>api</li>\n</ol>\n<p>将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。</p>\n<pre><code class=\"language-jsx\">const CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return &#x3C;CountChild count={count} />\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>利用<code>useMemo</code> hooks</li>\n</ol>\n<p>一个组件内部使用<code>useMemo</code>，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。</p>\n<pre><code class=\"language-jsx\">const MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      &#x3C;div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      &#x3C;/div>\r\n    )\r\n  }, [price])\r\n}\n</code></pre>\n<h2>Full Code</h2>"
        },
        "_id": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
        "_raw": {
          "sourceFilePath": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
          "sourceFileName": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "using-memo-and-useMemo-to-optimize-useContext-in-React"
        },
        "type": "Post",
        "url": "/post/using-memo-and-useMemo-to-optimize-useContext-in-React"
      },
      "documentHash": "1669299082048",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "type-operate-in-typescript.md": {
      "document": {
        "title": "TypeScript类型操作",
        "date": "2022-05-28T00:00:00.000Z",
        "slug": "type-operate-in-typescript",
        "excerpt": "根据TypeScript官方文档学习TS类型操作的笔记。",
        "tags": [
          "TypeScript"
        ],
        "category": "Tech",
        "body": {
          "raw": "\r\nTypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。\r\n\r\n## 泛型\r\n\r\n### Hello World\r\n\r\n用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n```\r\n\r\n虽然使用`any`也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是`number`，我们所知的只是返回值可能是任意类型。\r\n\r\n使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 _类型变量_: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。\r\n\r\n这样在恒等函数里输入的参数类型为`number`，返回值类型便为`number`，参数类型为`string`，返回值类型便为`string`。\r\n\r\n### 泛型类型\r\n\r\n下面会展示函数自身的类型和如何创建泛型接口（generic interface）。\r\n\r\n泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: <Type>(arg: Type) => Type = identity\r\n```\r\n\r\n或者已对象字面量类型：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { <Input>(arg: Input): Input } = identity\r\n```\r\n\r\n接下来根据上面示例写第一个泛型接口：\r\n\r\n```ts\r\ninterface GenericIdentityFn {\r\n  <Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn<number> = identity  // 指定类型\r\n```\r\n\r\n### 泛型类\r\n\r\n泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (<>) 中有一个泛型类型参数列表。\r\n\r\n```ts\r\nclass GenericNumber<NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber<number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\r\n```\r\n\r\n### 泛型约束\r\n\r\n```ts\r\nfunction loggingIdentity<Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\r\n```\r\n\r\n在上面的例子中，我们想获取arg的`length`属性，但编译器认为不是所有的类型都有`length`属性，所以警告我们不能做出这个假设。\r\n\r\n我们不想使用任何类型，而是希望将此函数限制为使用具有`length`属性的属性。可以使用`interface`接口和`extends`关键字来表示约束。\r\n\r\n```ts\r\ninterface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity<Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\r\n```\r\n\r\n### 在泛型约束中使用类型参数\r\n\r\n你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在`obj`上不存在属性，所以在这两个类型间放置一个约束：\r\n\r\n```ts\r\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\r\n```\r\n\r\n### 在泛型中使用Class类型\r\n\r\n在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:\r\n\r\n```ts\r\nfunction create<Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\r\n```\r\n使用原型属性来推断和约束构造函数和类类型的实例之间的关系。\r\n\r\n```ts\r\nclass BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance<A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\r\n```\r\n\r\n## `keyof` 类型操作符\r\n\r\n`keyof` 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。\r\n\r\n```ts\r\ntype Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\r\n```\r\n\r\n上面例子中，`M`是`string | number`，这是因为JavaScript对象的键总是会被转成一个字符串，所以`obj[0]`与`obj['0']`是一样的。\r\n\r\n当与映射类型结合使用时，keyof 类型变得特别有用。\r\n\r\n## `typeof`类型操作符\r\n\r\n",
          "html": "<p>TypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。</p>\n<h2>泛型</h2>\n<h3>Hello World</h3>\n<p>用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\n</code></pre>\n<p>虽然使用<code>any</code>也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是<code>number</code>，我们所知的只是返回值可能是任意类型。</p>\n<p>使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 <em>类型变量</em>: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。</p>\n<p>这样在恒等函数里输入的参数类型为<code>number</code>，返回值类型便为<code>number</code>，参数类型为<code>string</code>，返回值类型便为<code>string</code>。</p>\n<h3>泛型类型</h3>\n<p>下面会展示函数自身的类型和如何创建泛型接口（generic interface）。</p>\n<p>泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: &#x3C;Type>(arg: Type) => Type = identity\n</code></pre>\n<p>或者已对象字面量类型：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { &#x3C;Input>(arg: Input): Input } = identity\n</code></pre>\n<p>接下来根据上面示例写第一个泛型接口：</p>\n<pre><code class=\"language-ts\">interface GenericIdentityFn {\r\n  &#x3C;Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn&#x3C;number> = identity  // 指定类型\n</code></pre>\n<h3>泛型类</h3>\n<p>泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (&#x3C;>) 中有一个泛型类型参数列表。</p>\n<pre><code class=\"language-ts\">class GenericNumber&#x3C;NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber&#x3C;number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\n</code></pre>\n<h3>泛型约束</h3>\n<pre><code class=\"language-ts\">function loggingIdentity&#x3C;Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\n</code></pre>\n<p>在上面的例子中，我们想获取arg的<code>length</code>属性，但编译器认为不是所有的类型都有<code>length</code>属性，所以警告我们不能做出这个假设。</p>\n<p>我们不想使用任何类型，而是希望将此函数限制为使用具有<code>length</code>属性的属性。可以使用<code>interface</code>接口和<code>extends</code>关键字来表示约束。</p>\n<pre><code class=\"language-ts\">interface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity&#x3C;Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\n</code></pre>\n<h3>在泛型约束中使用类型参数</h3>\n<p>你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在<code>obj</code>上不存在属性，所以在这两个类型间放置一个约束：</p>\n<pre><code class=\"language-ts\">function getProperty&#x3C;Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\n</code></pre>\n<h3>在泛型中使用Class类型</h3>\n<p>在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:</p>\n<pre><code class=\"language-ts\">function create&#x3C;Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\n</code></pre>\n<p>使用原型属性来推断和约束构造函数和类类型的实例之间的关系。</p>\n<pre><code class=\"language-ts\">class BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance&#x3C;A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\n</code></pre>\n<h2><code>keyof</code> 类型操作符</h2>\n<p><code>keyof</code> 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。</p>\n<pre><code class=\"language-ts\">type Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\n</code></pre>\n<p>上面例子中，<code>M</code>是<code>string | number</code>，这是因为JavaScript对象的键总是会被转成一个字符串，所以<code>obj[0]</code>与<code>obj['0']</code>是一样的。</p>\n<p>当与映射类型结合使用时，keyof 类型变得特别有用。</p>\n<h2><code>typeof</code>类型操作符</h2>"
        },
        "_id": "type-operate-in-typescript.md",
        "_raw": {
          "sourceFilePath": "type-operate-in-typescript.md",
          "sourceFileName": "type-operate-in-typescript.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "type-operate-in-typescript"
        },
        "type": "Post",
        "url": "/post/type-operate-in-typescript"
      },
      "documentHash": "1669041084625",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "toc-test.md": {
      "document": {
        "title": "TOC测试",
        "date": "2022-07-20T00:00:00.000Z",
        "slug": "toc-test",
        "tags": [
          "Markdown",
          "Test"
        ],
        "category": "测试",
        "body": {
          "raw": "\r\n# Alpha\r\n\r\n## 目录\r\n\r\n## Bravo\r\n\r\n### Charlie\r\n\r\n## Delta",
          "html": "<h1>Alpha</h1>\n<h2>目录</h2>\n<h2>Bravo</h2>\n<h3>Charlie</h3>\n<h2>Delta</h2>"
        },
        "_id": "toc-test.md",
        "_raw": {
          "sourceFilePath": "toc-test.md",
          "sourceFileName": "toc-test.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "toc-test"
        },
        "type": "Post",
        "url": "/post/toc-test"
      },
      "documentHash": "1669041084624",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "markdown-examples.md": {
      "document": {
        "title": "Markdown Examples",
        "date": "2021-03-19T00:00:00.000Z",
        "slug": "markdown-examples",
        "tags": [
          "Markdown"
        ],
        "category": "测试",
        "coverImage": "/assets/post/pre-rendering/cover.png",
        "body": {
          "raw": "\r\n# 目录\r\n\r\n# Markdown Examples\r\n\r\n## h2 Heading\r\n\r\n### h3 Heading\r\n\r\n#### h4 Heading\r\n\r\n##### h5 Heading\r\n\r\n###### h6 Heading\r\n\r\n## Emphasis\r\n\r\n**This is bold text**\r\n\r\n_This is italic text_\r\n\r\n~~Strikethrough~~\r\n\r\n## Blockquotes\r\n\r\n> Develop. Preview. Ship. – Vercel\r\n\r\n## Lists\r\n\r\nUnordered\r\n\r\n- Lorem ipsum dolor sit amet\r\n- Consectetur adipiscing elit\r\n- Integer molestie lorem at massa\r\n\r\nOrdered\r\n\r\n1. Lorem ipsum dolor sit amet\r\n2. Consectetur adipiscing elit\r\n3. Integer molestie lorem at massa\r\n\r\n## Code\r\n\r\nInline `code`\r\n\r\n```js\r\nexport default function Nextra({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <link\r\n          rel=\"alternate\"\r\n          type=\"application/rss+xml\"\r\n          title=\"RSS\"\r\n          href=\"/feed.xml\"\r\n        />\r\n        <link\r\n          rel=\"preload\"\r\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\r\n          as=\"font\"\r\n          type=\"font/woff2\"\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      </Head>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n## Tables\r\n\r\n| **Option** | **Description**                                                                                                             |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------- |\r\n| First      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Second     | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Third      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n\r\n## Links\r\n\r\n- [Next.js](https://nextjs.org)\r\n- [Nextra](https://nextra.vercel.app/)\r\n- [Vercel](http://vercel.com)\r\n\r\n### Footnotes\r\n\r\n- Footnote [^1].\r\n- Footnote [^2].\r\n\r\n[^1]: Footnote **can have markup**\r\n\r\nand multiple paragraphs.\r\n\r\n[^2]: Footnote text.\r\n",
          "html": "<h1>目录</h1>\n<h1>Markdown Examples</h1>\n<h2>h2 Heading</h2>\n<h3>h3 Heading</h3>\n<h4>h4 Heading</h4>\n<h5>h5 Heading</h5>\n<h6>h6 Heading</h6>\n<h2>Emphasis</h2>\n<p><strong>This is bold text</strong></p>\n<p><em>This is italic text</em></p>\n<p>~~Strikethrough~~</p>\n<h2>Blockquotes</h2>\n<blockquote>\n<p>Develop. Preview. Ship. – Vercel</p>\n</blockquote>\n<h2>Lists</h2>\n<p>Unordered</p>\n<ul>\n<li>Lorem ipsum dolor sit amet</li>\n<li>Consectetur adipiscing elit</li>\n<li>Integer molestie lorem at massa</li>\n</ul>\n<p>Ordered</p>\n<ol>\n<li>Lorem ipsum dolor sit amet</li>\n<li>Consectetur adipiscing elit</li>\n<li>Integer molestie lorem at massa</li>\n</ol>\n<h2>Code</h2>\n<p>Inline <code>code</code></p>\n<pre><code class=\"language-js\">export default function Nextra({ Component, pageProps }) {\r\n  return (\r\n    &#x3C;>\r\n      &#x3C;Head>\r\n        &#x3C;link\r\n          rel=\"alternate\"\r\n          type=\"application/rss+xml\"\r\n          title=\"RSS\"\r\n          href=\"/feed.xml\"\r\n        />\r\n        &#x3C;link\r\n          rel=\"preload\"\r\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\r\n          as=\"font\"\r\n          type=\"font/woff2\"\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      &#x3C;/Head>\r\n      &#x3C;Component {...pageProps} />\r\n    &#x3C;/>\r\n  )\r\n}\n</code></pre>\n<h2>Tables</h2>\n<p>| <strong>Option</strong> | <strong>Description</strong>                                                                                                             |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------- |\r\n| First      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Second     | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Third      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |</p>\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://nextjs.org\">Next.js</a></li>\n<li><a href=\"https://nextra.vercel.app/\">Nextra</a></li>\n<li><a href=\"http://vercel.com\">Vercel</a></li>\n</ul>\n<h3>Footnotes</h3>\n<ul>\n<li>Footnote [^1].</li>\n<li>Footnote [^2].</li>\n</ul>\n<p>[^1]: Footnote <strong>can have markup</strong></p>\n<p>and multiple paragraphs.</p>\n<p>[^2]: Footnote text.</p>"
        },
        "_id": "markdown-examples.md",
        "_raw": {
          "sourceFilePath": "markdown-examples.md",
          "sourceFileName": "markdown-examples.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "markdown-examples"
        },
        "type": "Post",
        "url": "/post/markdown-examples"
      },
      "documentHash": "1669472523006",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "reactivity-in-vue3.md": {
      "document": {
        "title": "VUE3响应式原理",
        "date": "2021-12-26T00:00:00.000Z",
        "slug": "reactivity-in-vue3",
        "excerpt": "Vue3实现响应式的方式与Vue2相比有一些变化，本文将整理Vue3中实现响应式的基本原理并实现一个响应式引擎。",
        "tags": [
          "JavaScript",
          "Vue"
        ],
        "category": "Tech",
        "body": {
          "raw": "\r\n> Vue3 实现响应式的方式与 Vue2 相比有一些变化，本文将整理 Vue3 中实现响应式的基本原理并实现一个响应式引擎。\r\n\r\n## 目录\r\n\r\n## 一个例子\r\n\r\n在 Vue 中，当该 vue 实例中的 data 属性或者 computed 发生改变时，模板中值会自动更新。\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div>Price: ${{ price }}</div>\r\n  <div>Total: ${{ price * quantity }}</div>\r\n  <div>Taxes: ${{ totalPriceWithTax }}</div>\r\n</div>\r\n```\r\n\r\n```js\r\nvar vm = new Vue({\r\n    el: '#app'\r\n    data: {\r\n        price: 10.00,\r\n        quantity: 2\r\n    },\r\n    computed: {\r\n        totalPriceWithTax() {\r\n            return this.price * this.quantity * 1.03\r\n        }\r\n    }\r\n})\r\n\r\n```\r\n\r\nVue 是怎么知道去更新所有东西的？\r\n因为这并不是 JavaScript 的工作方式。如下，在 JS 中，改变 price 的值，total 并不会发生改变。\r\n\r\n```js\r\nlet price = 5\r\nlet quantity = 2\r\nlet total = price * quantity\r\n\r\nconsole.log(`total is ${total}`)\r\nprice = 20\r\nconsole.log(`total is ${total}`)\r\n```\r\n\r\n## Reactivity\r\n\r\n**问题 1: 我们怎么去存储`total`的计算函数，当`price`或者`quantity`发生改变时再去运行一遍？而且可能不止保存了一个函数。**\r\n\r\n```js\r\nlet price = 5\r\nlet quantity = 2\r\nlet total = 0\r\n\r\nlet dep = new Set() // 存储所有effect的容器\r\n\r\n// 想要存储的代码\r\nlet effect = () => {\r\n  total = price * quantity\r\n}\r\n// 添加代码\r\nfunction track() {\r\n  dep.add(effect)\r\n}\r\n// 重新运行容器中的所有代码\r\nfunction trigger() {\r\n  dep.forEach((effect) => effect())\r\n}\r\n\r\ntrack()\r\neffect()\r\nconsole.log(total) // 10\r\nquantity = 3\r\ntrigger()\r\nconsole.log(total) // 15\r\n```\r\n\r\n重写代码，在一个匿名函数中计算总数，把它存储在`effect`中。想要保存 effect 中的代码时，需要调用`track`，然后调用`effect`执行首次计算。之后将调用`trigger`来运行所有保存了的代码。\r\n\r\n这里的`effect`、`track`、`trigger`在 Vue3 响应式源码中都有相同的名称。\r\n\r\n**问题 2：通常一个对象中会有多个属性，而且每个属性都需要自己的`dep`（依赖关系，或者说 `effect`的 Set），如何存储这些`dep`呢？**\r\n\r\n要将`deps`存储起来，需要创建一个`depsMap`，它是一个存储了每个属性及其 dep 对象的`Map`。ES6 中一个`Map`拥有一个键值对，使用对象的属性名作为键，值就是一个`dep`(effect 集)了。\r\n\r\n```js\r\nconst depsMap = new Map()\r\n\r\nfunction track(key) {\r\n  let dep = depsMap.get(key) // 通过对象属性名获取dep\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set())) // 如果没有，就创建一个\r\n  }\r\n  dep.add(effect) // 添加effect\r\n}\r\n\r\nfunction trigger() {\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect() // 如果dep存在，执行每个effect\r\n    })\r\n  }\r\n}\r\n\r\nlet product = { price: 5, quantity: 2 }\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\ntrack('quantity')\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 3\r\ntrigger('quantity')\r\nconsole.log(total) // 15\r\n```\r\n\r\n**问题 3：如果我们有多个响应式对象呢？**\r\n\r\n这里我们需要一个对象（比如 Map），它的键以某种方式引用了响应式对象。在 Vue3 中，它被称为`targetMap`，是一个 WeakMap 类型。\r\n\r\nWeakMap 简单说就是一个 Map，但是它的键是一个对象。\r\n\r\n```js\r\nconst targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  let depsMap = targetMap.get(target) // 获取目标（响应式对象）当前的depsMap, 如 product\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key) // 获取属性的依赖对象，如 quantity\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  dep.add(effect)\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target) // 这个对象是否有存在依赖的属性？\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key) // 检查这个属性是否有依赖\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    }) // 运行\r\n  }\r\n}\r\n\r\nlet product = { price: 5, quantity: 2 }\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\ntrack(product, 'quantity')\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 3\r\ntrigger(product, 'quantity')\r\nconsole.log(total) // 15\r\n```\r\n\r\n如上：`targetMap`中存储了与每个“响应式对象属性”关联的依赖，`depsMap`存储了每个属性的依赖，而`dep`是一个`effect`集（Set）的依赖，这些`effect`应该在值发生改变时重新运行。\r\n\r\n## Proxy 和 Reflect\r\n\r\n我们已经有了存储不同`effect`的方法，但是还不能让`effect`自动重新运行。我们希望响应式引擎自动调用跟踪和触发，即当访问响应式对象的属性（或使用了 GET）时，正是要调用`track`去保存`effect`的时候；如果对象的属性改变了（或者说使用了 SET）时，是调用`trigger`来运行那些保存了的`effect`的时候。这是问题就变成了我们如何拦截这些`GET`和`SET`方法？\r\n\r\n在 Vue2 中，使用 ES5 的`Obejct.defineProperty()`去拦截`GET`和`SET`。在 Vue3 中，使用的是 ES6 的`Proxy`和`Reflect`（反射和代理）。\r\n\r\n```js\r\nconst targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  let depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  dep.add(effect)\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      // console.log('get was called')\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      // console.log('set was called')\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 }) // 返回一个proxy对象，可以像原始对象一样使用\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 4\r\nconsole.log(total) // 20\r\n```\r\n\r\n如上：我们的响应式函数`reactive()`返回一个对象的代理，在第一次运行`effect`拿到 price 属性时，它将运行`track(product, 'price')`，这时在`targetMap`中将为 product 对象创建一个新的映射，它的值是一个新的`depsMap`，将 price 属性映射到一个新的`deps`，然后将全部 effect 加入到`deps`集中。调用`product.quantity`时同理。然后设置 quantity 为 3 时，会调用`trigger(product, 'quantity')`，然后运行存储了的`effect`。\r\n\r\n## activeEffect 和 ref\r\n\r\n如果我们再添加另一个`get`，比如`product.quantity`，它会调用`track(product, 'quantity')`，走一遍`targetMap`和各种`dep`，以确保当前`effect`被记录下来了。这不是我们想要的，我们应该只在`effect`中调用追踪函数。\r\n\r\n为此需要引入一个`activeEffect`变量，代表正在运行中的`effect`，用一个`effect`函数包裹，并修改`track()`函数。\r\n\r\n```js\r\nconst targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  if (activeEffect) {\r\n    // 只在有activeEffect时追踪\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Set()))\r\n    }\r\n    dep.add(activeEffect)\r\n  }\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nlet activeEffect = null // 正在运行的effect\r\nfunction effect(eff) {\r\n  activeEffect = eff // 设置activeEffect\r\n  activeEffect() // 运行\r\n  activeEffect = null // 复位activeEffect\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 }) // 返回一个proxy对象，可以像原始对象一样使用\r\nlet salePrice = 0\r\nlet total = 0\r\n// let effect = () => {\r\n//     total = product.price * product.quantity\r\n// }\r\n// effect()       // 不再需要调用，会在传递函数时调用\r\neffect(() => {\r\n  total = product.price * product.quantity\r\n})\r\neffect(() => {\r\n  salePrice = product.price * 0.9\r\n})\r\nconsole.log(`在更新前 total = ${total}, salePrice = ${salePrice}`) // 10, 4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice}`) // 15, 4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice}`) // 30, 9\r\n```\r\n\r\n这样`track`函数只有在有`activeEffect`时才会运行。\r\n\r\n在上面的代码中，如果想根据 salePrice 计算 total 是不行的，因为当 salePrice 被设置的时候，需要重新计算 total。但是 salePrice 不是响应式的！\r\n\r\n这时就需要 Vue3 中的`ref`了。`ref`接受一个值并返回一个响应的可变的`Ref`对象。`Ref`对象只有一个`.value`属性，指向内部的值。\r\n\r\nVue3 中是使用**对象访问器**实现`ref`的。对象访问器有时也被称为计算属性（不是 Vue 中的）。下面是对象访问器`getter`和`setter`的用法。\r\n\r\n```js\r\nlet uer = {\r\n    firstName: 'Joe',\r\n    lastName: 'Mike',\r\n\r\n    get fullName() {\r\n        return `${this.firstName} ${this.lastName}`\r\n    },\r\n    set fullName() {\r\n        [this.firstName, this.lastName] = value.split(' ')\r\n    }\r\n}\r\n\r\nconsole.log(`Name is ${user.fullName}`)  // Name is Joe Mike\r\nuser.fullName = 'Cris Paul'\r\nconsole.log(`Name is ${user.fullName}`)   // Name is Cris Paul\r\n```\r\n\r\n现在如何用对象访问器来定义`Ref`呢？\r\n\r\n```js\r\n// ...\r\n\r\nfunction ref(raw) {\r\n  const r = {\r\n    get value() {\r\n      track(r, 'value')\r\n      return raw\r\n    },\r\n    set value(newVal) {\r\n      if (raw !== newVal) {\r\n        raw = newVal\r\n        trigger(r, 'value')\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n// ...\r\n\r\nlet product = reactive({ price: 5, quantity: 2 })\r\nlet salePrice = ref(0)\r\nlet total = 0\r\n\r\neffect(() => {\r\n  total = salePrice.value * product.quantity\r\n})\r\neffect(() => {\r\n  salePrice.value = product.price * 0.9\r\n})\r\nconsole.log(`在更新前 total = ${total}, salePrice = ${salePrice.value}`) // 10,  4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice.value}`) // 13.5,  4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice.value}`) // 27, 9\r\n```\r\n\r\n## Computed\r\n\r\n在之前的代码种`effect`方法可以用 Vue 中的`Computed`方法去代替，只需返回一个匿名函数到一个计算函数`Computed()`中，然后返回一个值。就像：\r\n\r\n```js\r\nlet product = reactive({ price: 5, quantity: 2 })\r\n// let salePrice = ref(0)\r\n// let total = 0\r\n\r\n// effect(() => {\r\n//     total = salePrice.value * product.quantity\r\n// })\r\n\r\n// effect(() => {\r\n//     salePrice.value = product.price * 0.9\r\n// })\r\n\r\nlet salePrice = computed(() => {\r\n  return product.price * 0.9\r\n})\r\n\r\nlet total = computed(() => {\r\n  return salePrice.value * product.quantity\r\n})\r\n```\r\n\r\n那么如何定义`Computed`方法呢？计算属性或计算值是响应式的，有点像`Ref`。\r\n\r\n首先，我们将定义一个计算函数，它接收一个称之为`getter`的参数，在函数内部，将创建一个称为`result`的响应式引用，然后在`effect`中运行 getter，这样就能监听响应值，然后把`getter`赋值于`result.value`，最后返回`result`。\r\n\r\n全部代码：\r\n\r\n```js\r\nconst targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  if (activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Set()))\r\n    }\r\n    dep.add(activeEffect)\r\n  }\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nfunction ref(raw) {\r\n  const r = {\r\n    get value() {\r\n      track(r, 'value')\r\n      return raw\r\n    },\r\n    set value(newVal) {\r\n      if (raw !== newVal) {\r\n        raw = newVal\r\n        trigger(r, 'value')\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nfunction computed(getter) {\r\n  let result = ref()\r\n  effect(() => (result.value = getter()))\r\n  return result\r\n}\r\n\r\nlet activeEffect = null\r\nfunction effect(eff) {\r\n  activeEffect = eff\r\n  activeEffect()\r\n  activeEffect = null\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 })\r\nlet salePrice = computed(() => {\r\n  return product.price * 0.9\r\n})\r\n\r\nlet total = computed(() => {\r\n  return salePrice.value * product.quantity\r\n})\r\n\r\nconsole.log(`在更新前 total = ${total.value}, salePrice = ${salePrice.value}`) // 10,  4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total.value}, salePrice = ${salePrice.value}`) // 13.5,  4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total.value}, salePrice = ${salePrice.value}`) // 27, 9     // 30, 9\r\n```\r\n\r\n以上就是 Vue3 中实现响应式的一些基础代码。\r\n\r\n在 Vue2 中，在创建一个响应式对象之后，无法再添加新的响应式属性，例如，设置 product 对象的 name 为'Shoes'，执行一次`effect`，但是如果改变 product 的 name 值为'Socks'，并不会运行`effect`。这是因为在 Vue2 中，`Get`和`Set`钩子是被添加到各个属性下的，如果要增加新的属性，需要像`Vue.set('product', 'name', 'Socks')`这样做。但是在 Vue3 中，使用了代理`Proxy`，意味着我们可以添加新属性，然后它们会自动变成响应式。\r\n\r\n<p align=\"right\"> ———— 学习整理自 Vue Mastery </p>\r\n",
          "html": "<blockquote>\n<p>Vue3 实现响应式的方式与 Vue2 相比有一些变化，本文将整理 Vue3 中实现响应式的基本原理并实现一个响应式引擎。</p>\n</blockquote>\n<h2>目录</h2>\n<h2>一个例子</h2>\n<p>在 Vue 中，当该 vue 实例中的 data 属性或者 computed 发生改变时，模板中值会自动更新。</p>\n<pre><code class=\"language-html\">&#x3C;div id=\"app\">\r\n  &#x3C;div>Price: ${{ price }}&#x3C;/div>\r\n  &#x3C;div>Total: ${{ price * quantity }}&#x3C;/div>\r\n  &#x3C;div>Taxes: ${{ totalPriceWithTax }}&#x3C;/div>\r\n&#x3C;/div>\n</code></pre>\n<pre><code class=\"language-js\">var vm = new Vue({\r\n    el: '#app'\r\n    data: {\r\n        price: 10.00,\r\n        quantity: 2\r\n    },\r\n    computed: {\r\n        totalPriceWithTax() {\r\n            return this.price * this.quantity * 1.03\r\n        }\r\n    }\r\n})\r\n\n</code></pre>\n<p>Vue 是怎么知道去更新所有东西的？\r\n因为这并不是 JavaScript 的工作方式。如下，在 JS 中，改变 price 的值，total 并不会发生改变。</p>\n<pre><code class=\"language-js\">let price = 5\r\nlet quantity = 2\r\nlet total = price * quantity\r\n\r\nconsole.log(`total is ${total}`)\r\nprice = 20\r\nconsole.log(`total is ${total}`)\n</code></pre>\n<h2>Reactivity</h2>\n<p><strong>问题 1: 我们怎么去存储<code>total</code>的计算函数，当<code>price</code>或者<code>quantity</code>发生改变时再去运行一遍？而且可能不止保存了一个函数。</strong></p>\n<pre><code class=\"language-js\">let price = 5\r\nlet quantity = 2\r\nlet total = 0\r\n\r\nlet dep = new Set() // 存储所有effect的容器\r\n\r\n// 想要存储的代码\r\nlet effect = () => {\r\n  total = price * quantity\r\n}\r\n// 添加代码\r\nfunction track() {\r\n  dep.add(effect)\r\n}\r\n// 重新运行容器中的所有代码\r\nfunction trigger() {\r\n  dep.forEach((effect) => effect())\r\n}\r\n\r\ntrack()\r\neffect()\r\nconsole.log(total) // 10\r\nquantity = 3\r\ntrigger()\r\nconsole.log(total) // 15\n</code></pre>\n<p>重写代码，在一个匿名函数中计算总数，把它存储在<code>effect</code>中。想要保存 effect 中的代码时，需要调用<code>track</code>，然后调用<code>effect</code>执行首次计算。之后将调用<code>trigger</code>来运行所有保存了的代码。</p>\n<p>这里的<code>effect</code>、<code>track</code>、<code>trigger</code>在 Vue3 响应式源码中都有相同的名称。</p>\n<p><strong>问题 2：通常一个对象中会有多个属性，而且每个属性都需要自己的<code>dep</code>（依赖关系，或者说 <code>effect</code>的 Set），如何存储这些<code>dep</code>呢？</strong></p>\n<p>要将<code>deps</code>存储起来，需要创建一个<code>depsMap</code>，它是一个存储了每个属性及其 dep 对象的<code>Map</code>。ES6 中一个<code>Map</code>拥有一个键值对，使用对象的属性名作为键，值就是一个<code>dep</code>(effect 集)了。</p>\n<pre><code class=\"language-js\">const depsMap = new Map()\r\n\r\nfunction track(key) {\r\n  let dep = depsMap.get(key) // 通过对象属性名获取dep\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set())) // 如果没有，就创建一个\r\n  }\r\n  dep.add(effect) // 添加effect\r\n}\r\n\r\nfunction trigger() {\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect() // 如果dep存在，执行每个effect\r\n    })\r\n  }\r\n}\r\n\r\nlet product = { price: 5, quantity: 2 }\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\ntrack('quantity')\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 3\r\ntrigger('quantity')\r\nconsole.log(total) // 15\n</code></pre>\n<p><strong>问题 3：如果我们有多个响应式对象呢？</strong></p>\n<p>这里我们需要一个对象（比如 Map），它的键以某种方式引用了响应式对象。在 Vue3 中，它被称为<code>targetMap</code>，是一个 WeakMap 类型。</p>\n<p>WeakMap 简单说就是一个 Map，但是它的键是一个对象。</p>\n<pre><code class=\"language-js\">const targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  let depsMap = targetMap.get(target) // 获取目标（响应式对象）当前的depsMap, 如 product\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key) // 获取属性的依赖对象，如 quantity\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  dep.add(effect)\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target) // 这个对象是否有存在依赖的属性？\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key) // 检查这个属性是否有依赖\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    }) // 运行\r\n  }\r\n}\r\n\r\nlet product = { price: 5, quantity: 2 }\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\ntrack(product, 'quantity')\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 3\r\ntrigger(product, 'quantity')\r\nconsole.log(total) // 15\n</code></pre>\n<p>如上：<code>targetMap</code>中存储了与每个“响应式对象属性”关联的依赖，<code>depsMap</code>存储了每个属性的依赖，而<code>dep</code>是一个<code>effect</code>集（Set）的依赖，这些<code>effect</code>应该在值发生改变时重新运行。</p>\n<h2>Proxy 和 Reflect</h2>\n<p>我们已经有了存储不同<code>effect</code>的方法，但是还不能让<code>effect</code>自动重新运行。我们希望响应式引擎自动调用跟踪和触发，即当访问响应式对象的属性（或使用了 GET）时，正是要调用<code>track</code>去保存<code>effect</code>的时候；如果对象的属性改变了（或者说使用了 SET）时，是调用<code>trigger</code>来运行那些保存了的<code>effect</code>的时候。这是问题就变成了我们如何拦截这些<code>GET</code>和<code>SET</code>方法？</p>\n<p>在 Vue2 中，使用 ES5 的<code>Obejct.defineProperty()</code>去拦截<code>GET</code>和<code>SET</code>。在 Vue3 中，使用的是 ES6 的<code>Proxy</code>和<code>Reflect</code>（反射和代理）。</p>\n<pre><code class=\"language-js\">const targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  let depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    targetMap.set(target, (depsMap = new Map()))\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (!dep) {\r\n    depsMap.set(key, (dep = new Set()))\r\n  }\r\n  dep.add(effect)\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      // console.log('get was called')\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      // console.log('set was called')\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 }) // 返回一个proxy对象，可以像原始对象一样使用\r\nlet total = 0\r\nlet effect = () => {\r\n  total = product.price * product.quantity\r\n}\r\neffect()\r\nconsole.log(total) // 10\r\nproduct.quantity = 4\r\nconsole.log(total) // 20\n</code></pre>\n<p>如上：我们的响应式函数<code>reactive()</code>返回一个对象的代理，在第一次运行<code>effect</code>拿到 price 属性时，它将运行<code>track(product, 'price')</code>，这时在<code>targetMap</code>中将为 product 对象创建一个新的映射，它的值是一个新的<code>depsMap</code>，将 price 属性映射到一个新的<code>deps</code>，然后将全部 effect 加入到<code>deps</code>集中。调用<code>product.quantity</code>时同理。然后设置 quantity 为 3 时，会调用<code>trigger(product, 'quantity')</code>，然后运行存储了的<code>effect</code>。</p>\n<h2>activeEffect 和 ref</h2>\n<p>如果我们再添加另一个<code>get</code>，比如<code>product.quantity</code>，它会调用<code>track(product, 'quantity')</code>，走一遍<code>targetMap</code>和各种<code>dep</code>，以确保当前<code>effect</code>被记录下来了。这不是我们想要的，我们应该只在<code>effect</code>中调用追踪函数。</p>\n<p>为此需要引入一个<code>activeEffect</code>变量，代表正在运行中的<code>effect</code>，用一个<code>effect</code>函数包裹，并修改<code>track()</code>函数。</p>\n<pre><code class=\"language-js\">const targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  if (activeEffect) {\r\n    // 只在有activeEffect时追踪\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Set()))\r\n    }\r\n    dep.add(activeEffect)\r\n  }\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nlet activeEffect = null // 正在运行的effect\r\nfunction effect(eff) {\r\n  activeEffect = eff // 设置activeEffect\r\n  activeEffect() // 运行\r\n  activeEffect = null // 复位activeEffect\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 }) // 返回一个proxy对象，可以像原始对象一样使用\r\nlet salePrice = 0\r\nlet total = 0\r\n// let effect = () => {\r\n//     total = product.price * product.quantity\r\n// }\r\n// effect()       // 不再需要调用，会在传递函数时调用\r\neffect(() => {\r\n  total = product.price * product.quantity\r\n})\r\neffect(() => {\r\n  salePrice = product.price * 0.9\r\n})\r\nconsole.log(`在更新前 total = ${total}, salePrice = ${salePrice}`) // 10, 4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice}`) // 15, 4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice}`) // 30, 9\n</code></pre>\n<p>这样<code>track</code>函数只有在有<code>activeEffect</code>时才会运行。</p>\n<p>在上面的代码中，如果想根据 salePrice 计算 total 是不行的，因为当 salePrice 被设置的时候，需要重新计算 total。但是 salePrice 不是响应式的！</p>\n<p>这时就需要 Vue3 中的<code>ref</code>了。<code>ref</code>接受一个值并返回一个响应的可变的<code>Ref</code>对象。<code>Ref</code>对象只有一个<code>.value</code>属性，指向内部的值。</p>\n<p>Vue3 中是使用<strong>对象访问器</strong>实现<code>ref</code>的。对象访问器有时也被称为计算属性（不是 Vue 中的）。下面是对象访问器<code>getter</code>和<code>setter</code>的用法。</p>\n<pre><code class=\"language-js\">let uer = {\r\n    firstName: 'Joe',\r\n    lastName: 'Mike',\r\n\r\n    get fullName() {\r\n        return `${this.firstName} ${this.lastName}`\r\n    },\r\n    set fullName() {\r\n        [this.firstName, this.lastName] = value.split(' ')\r\n    }\r\n}\r\n\r\nconsole.log(`Name is ${user.fullName}`)  // Name is Joe Mike\r\nuser.fullName = 'Cris Paul'\r\nconsole.log(`Name is ${user.fullName}`)   // Name is Cris Paul\n</code></pre>\n<p>现在如何用对象访问器来定义<code>Ref</code>呢？</p>\n<pre><code class=\"language-js\">// ...\r\n\r\nfunction ref(raw) {\r\n  const r = {\r\n    get value() {\r\n      track(r, 'value')\r\n      return raw\r\n    },\r\n    set value(newVal) {\r\n      if (raw !== newVal) {\r\n        raw = newVal\r\n        trigger(r, 'value')\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n// ...\r\n\r\nlet product = reactive({ price: 5, quantity: 2 })\r\nlet salePrice = ref(0)\r\nlet total = 0\r\n\r\neffect(() => {\r\n  total = salePrice.value * product.quantity\r\n})\r\neffect(() => {\r\n  salePrice.value = product.price * 0.9\r\n})\r\nconsole.log(`在更新前 total = ${total}, salePrice = ${salePrice.value}`) // 10,  4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice.value}`) // 13.5,  4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total}, salePrice = ${salePrice.value}`) // 27, 9\n</code></pre>\n<h2>Computed</h2>\n<p>在之前的代码种<code>effect</code>方法可以用 Vue 中的<code>Computed</code>方法去代替，只需返回一个匿名函数到一个计算函数<code>Computed()</code>中，然后返回一个值。就像：</p>\n<pre><code class=\"language-js\">let product = reactive({ price: 5, quantity: 2 })\r\n// let salePrice = ref(0)\r\n// let total = 0\r\n\r\n// effect(() => {\r\n//     total = salePrice.value * product.quantity\r\n// })\r\n\r\n// effect(() => {\r\n//     salePrice.value = product.price * 0.9\r\n// })\r\n\r\nlet salePrice = computed(() => {\r\n  return product.price * 0.9\r\n})\r\n\r\nlet total = computed(() => {\r\n  return salePrice.value * product.quantity\r\n})\n</code></pre>\n<p>那么如何定义<code>Computed</code>方法呢？计算属性或计算值是响应式的，有点像<code>Ref</code>。</p>\n<p>首先，我们将定义一个计算函数，它接收一个称之为<code>getter</code>的参数，在函数内部，将创建一个称为<code>result</code>的响应式引用，然后在<code>effect</code>中运行 getter，这样就能监听响应值，然后把<code>getter</code>赋值于<code>result.value</code>，最后返回<code>result</code>。</p>\n<p>全部代码：</p>\n<pre><code class=\"language-js\">const targetMap = new WeakMap()\r\n\r\nfunction track(target, key) {\r\n  if (activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = new Set()))\r\n    }\r\n    dep.add(activeEffect)\r\n  }\r\n}\r\n\r\nfunction trigger(target, key) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    return\r\n  }\r\n  let dep = depsMap.get(key)\r\n  if (dep) {\r\n    dep.forEach((effect) => {\r\n      effect()\r\n    })\r\n  }\r\n}\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get(target, key, receiver) {\r\n      let result = Reflect.get(target, key, receiver)\r\n      track(target, key)\r\n      return result\r\n    },\r\n    set(target, key, value, receiver) {\r\n      let oldValue = target[key]\r\n      let result = Reflect.set(target, key, value, receiver)\r\n      if (oldValue != value) {\r\n        trigger(target, key)\r\n      }\r\n      return result\r\n    }\r\n  }\r\n  return new Proxy(target, handler)\r\n}\r\n\r\nfunction ref(raw) {\r\n  const r = {\r\n    get value() {\r\n      track(r, 'value')\r\n      return raw\r\n    },\r\n    set value(newVal) {\r\n      if (raw !== newVal) {\r\n        raw = newVal\r\n        trigger(r, 'value')\r\n      }\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\nfunction computed(getter) {\r\n  let result = ref()\r\n  effect(() => (result.value = getter()))\r\n  return result\r\n}\r\n\r\nlet activeEffect = null\r\nfunction effect(eff) {\r\n  activeEffect = eff\r\n  activeEffect()\r\n  activeEffect = null\r\n}\r\n\r\nlet product = reactive({ price: 5, quantity: 2 })\r\nlet salePrice = computed(() => {\r\n  return product.price * 0.9\r\n})\r\n\r\nlet total = computed(() => {\r\n  return salePrice.value * product.quantity\r\n})\r\n\r\nconsole.log(`在更新前 total = ${total.value}, salePrice = ${salePrice.value}`) // 10,  4.5\r\nproduct.quantity = 3\r\nconsole.log(`在更新后 total = ${total.value}, salePrice = ${salePrice.value}`) // 13.5,  4.5\r\nproduct.price = 10\r\nconsole.log(`在更新后 total = ${total.value}, salePrice = ${salePrice.value}`) // 27, 9     // 30, 9\n</code></pre>\n<p>以上就是 Vue3 中实现响应式的一些基础代码。</p>\n<p>在 Vue2 中，在创建一个响应式对象之后，无法再添加新的响应式属性，例如，设置 product 对象的 name 为'Shoes'，执行一次<code>effect</code>，但是如果改变 product 的 name 值为'Socks'，并不会运行<code>effect</code>。这是因为在 Vue2 中，<code>Get</code>和<code>Set</code>钩子是被添加到各个属性下的，如果要增加新的属性，需要像<code>Vue.set('product', 'name', 'Socks')</code>这样做。但是在 Vue3 中，使用了代理<code>Proxy</code>，意味着我们可以添加新属性，然后它们会自动变成响应式。</p>"
        },
        "_id": "reactivity-in-vue3.md",
        "_raw": {
          "sourceFilePath": "reactivity-in-vue3.md",
          "sourceFileName": "reactivity-in-vue3.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "reactivity-in-vue3"
        },
        "type": "Post",
        "url": "/post/reactivity-in-vue3"
      },
      "documentHash": "1669466998245",
      "hasWarnings": false,
      "documentTypeName": "Post"
    }
  }
}
