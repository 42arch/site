{
  "cacheItemsMap": {
    "markdow examples.md": {
      "document": {
        "title": "Markdown Examples",
        "date": "2021-03-19T00:00:00.000Z",
        "slug": "markdown-examples",
        "tags": [
          "Markdown"
        ],
        "category": "测试",
        "body": {
          "raw": "\r\n# 目录\r\n\r\n# Markdown Examples\r\n\r\n## h2 Heading\r\n\r\n### h3 Heading\r\n\r\n#### h4 Heading\r\n\r\n##### h5 Heading\r\n\r\n###### h6 Heading\r\n\r\n## Emphasis\r\n\r\n**This is bold text**\r\n\r\n_This is italic text_\r\n\r\n~~Strikethrough~~\r\n\r\n## Blockquotes\r\n\r\n> Develop. Preview. Ship. – Vercel\r\n\r\n## Lists\r\n\r\nUnordered\r\n\r\n- Lorem ipsum dolor sit amet\r\n- Consectetur adipiscing elit\r\n- Integer molestie lorem at massa\r\n\r\nOrdered\r\n\r\n1. Lorem ipsum dolor sit amet\r\n2. Consectetur adipiscing elit\r\n3. Integer molestie lorem at massa\r\n\r\n## Code\r\n\r\nInline `code`\r\n\r\n```js\r\nexport default function Nextra({ Component, pageProps }) {\r\n  return (\r\n    <>\r\n      <Head>\r\n        <link\r\n          rel=\"alternate\"\r\n          type=\"application/rss+xml\"\r\n          title=\"RSS\"\r\n          href=\"/feed.xml\"\r\n        />\r\n        <link\r\n          rel=\"preload\"\r\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\r\n          as=\"font\"\r\n          type=\"font/woff2\"\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      </Head>\r\n      <Component {...pageProps} />\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n## Tables\r\n\r\n| **Option** | **Description**                                                                                                             |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------- |\r\n| First      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Second     | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Third      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n\r\n## Links\r\n\r\n- [Next.js](https://nextjs.org)\r\n- [Nextra](https://nextra.vercel.app/)\r\n- [Vercel](http://vercel.com)\r\n\r\n### Footnotes\r\n\r\n- Footnote [^1].\r\n- Footnote [^2].\r\n\r\n[^1]: Footnote **can have markup**\r\n\r\nand multiple paragraphs.\r\n\r\n[^2]: Footnote text.\r\n",
          "html": "<h1>目录</h1>\n<h1>Markdown Examples</h1>\n<h2>h2 Heading</h2>\n<h3>h3 Heading</h3>\n<h4>h4 Heading</h4>\n<h5>h5 Heading</h5>\n<h6>h6 Heading</h6>\n<h2>Emphasis</h2>\n<p><strong>This is bold text</strong></p>\n<p><em>This is italic text</em></p>\n<p>~~Strikethrough~~</p>\n<h2>Blockquotes</h2>\n<blockquote>\n<p>Develop. Preview. Ship. – Vercel</p>\n</blockquote>\n<h2>Lists</h2>\n<p>Unordered</p>\n<ul>\n<li>Lorem ipsum dolor sit amet</li>\n<li>Consectetur adipiscing elit</li>\n<li>Integer molestie lorem at massa</li>\n</ul>\n<p>Ordered</p>\n<ol>\n<li>Lorem ipsum dolor sit amet</li>\n<li>Consectetur adipiscing elit</li>\n<li>Integer molestie lorem at massa</li>\n</ol>\n<h2>Code</h2>\n<p>Inline <code>code</code></p>\n<pre><code class=\"language-js\">export default function Nextra({ Component, pageProps }) {\r\n  return (\r\n    &#x3C;>\r\n      &#x3C;Head>\r\n        &#x3C;link\r\n          rel=\"alternate\"\r\n          type=\"application/rss+xml\"\r\n          title=\"RSS\"\r\n          href=\"/feed.xml\"\r\n        />\r\n        &#x3C;link\r\n          rel=\"preload\"\r\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\r\n          as=\"font\"\r\n          type=\"font/woff2\"\r\n          crossOrigin=\"anonymous\"\r\n        />\r\n      &#x3C;/Head>\r\n      &#x3C;Component {...pageProps} />\r\n    &#x3C;/>\r\n  )\r\n}\n</code></pre>\n<h2>Tables</h2>\n<p>| <strong>Option</strong> | <strong>Description</strong>                                                                                                             |\r\n| ---------- | --------------------------------------------------------------------------------------------------------------------------- |\r\n| First      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Second     | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\r\n| Third      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |</p>\n<h2>Links</h2>\n<ul>\n<li><a href=\"https://nextjs.org\">Next.js</a></li>\n<li><a href=\"https://nextra.vercel.app/\">Nextra</a></li>\n<li><a href=\"http://vercel.com\">Vercel</a></li>\n</ul>\n<h3>Footnotes</h3>\n<ul>\n<li>Footnote [^1].</li>\n<li>Footnote [^2].</li>\n</ul>\n<p>[^1]: Footnote <strong>can have markup</strong></p>\n<p>and multiple paragraphs.</p>\n<p>[^2]: Footnote text.</p>"
        },
        "_id": "markdow examples.md",
        "_raw": {
          "sourceFilePath": "markdow examples.md",
          "sourceFileName": "markdow examples.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "markdow examples"
        },
        "type": "Post",
        "url": "/_posts/markdow examples"
      },
      "documentHash": "1669041084626",
      "hasWarnings": true,
      "documentTypeName": "Post"
    },
    "TOC测试.md": {
      "document": {
        "title": "TOC测试",
        "date": "2022-07-20T00:00:00.000Z",
        "slug": "toc-test",
        "tags": [
          "Markdown",
          "Test"
        ],
        "category": "测试",
        "body": {
          "raw": "\r\n# Alpha\r\n\r\n## 目录\r\n\r\n## Bravo\r\n\r\n### Charlie\r\n\r\n## Delta",
          "html": "<h1>Alpha</h1>\n<h2>目录</h2>\n<h2>Bravo</h2>\n<h3>Charlie</h3>\n<h2>Delta</h2>"
        },
        "_id": "TOC测试.md",
        "_raw": {
          "sourceFilePath": "TOC测试.md",
          "sourceFileName": "TOC测试.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "TOC测试"
        },
        "type": "Post",
        "url": "/_posts/TOC测试"
      },
      "documentHash": "1669041084624",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "TypeScript类型操作.md": {
      "document": {
        "title": "TypeScript类型操作",
        "date": "2022-05-28T00:00:00.000Z",
        "slug": "type-operate-in-typescript",
        "excerpt": "根据TypeScript官方文档学习TS类型操作的笔记。",
        "tags": [
          "TypeScript"
        ],
        "category": "Tech",
        "body": {
          "raw": "\r\nTypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。\r\n\r\n## 泛型\r\n\r\n### Hello World\r\n\r\n用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n```\r\n\r\n虽然使用`any`也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是`number`，我们所知的只是返回值可能是任意类型。\r\n\r\n使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 _类型变量_: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。\r\n\r\n这样在恒等函数里输入的参数类型为`number`，返回值类型便为`number`，参数类型为`string`，返回值类型便为`string`。\r\n\r\n### 泛型类型\r\n\r\n下面会展示函数自身的类型和如何创建泛型接口（generic interface）。\r\n\r\n泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: <Type>(arg: Type) => Type = identity\r\n```\r\n\r\n或者已对象字面量类型：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { <Input>(arg: Input): Input } = identity\r\n```\r\n\r\n接下来根据上面示例写第一个泛型接口：\r\n\r\n```ts\r\ninterface GenericIdentityFn {\r\n  <Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn<number> = identity  // 指定类型\r\n```\r\n\r\n### 泛型类\r\n\r\n泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (<>) 中有一个泛型类型参数列表。\r\n\r\n```ts\r\nclass GenericNumber<NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber<number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\r\n```\r\n\r\n### 泛型约束\r\n\r\n```ts\r\nfunction loggingIdentity<Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\r\n```\r\n\r\n在上面的例子中，我们想获取arg的`length`属性，但编译器认为不是所有的类型都有`length`属性，所以警告我们不能做出这个假设。\r\n\r\n我们不想使用任何类型，而是希望将此函数限制为使用具有`length`属性的属性。可以使用`interface`接口和`extends`关键字来表示约束。\r\n\r\n```ts\r\ninterface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity<Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\r\n```\r\n\r\n### 在泛型约束中使用类型参数\r\n\r\n你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在`obj`上不存在属性，所以在这两个类型间放置一个约束：\r\n\r\n```ts\r\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\r\n```\r\n\r\n### 在泛型中使用Class类型\r\n\r\n在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:\r\n\r\n```ts\r\nfunction create<Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\r\n```\r\n使用原型属性来推断和约束构造函数和类类型的实例之间的关系。\r\n\r\n```ts\r\nclass BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance<A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\r\n```\r\n\r\n## `keyof` 类型操作符\r\n\r\n`keyof` 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。\r\n\r\n```ts\r\ntype Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\r\n```\r\n\r\n上面例子中，`M`是`string | number`，这是因为JavaScript对象的键总是会被转成一个字符串，所以`obj[0]`与`obj['0']`是一样的。\r\n\r\n当与映射类型结合使用时，keyof 类型变得特别有用。\r\n\r\n## `typeof`类型操作符\r\n\r\n",
          "html": "<p>TypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。</p>\n<h2>泛型</h2>\n<h3>Hello World</h3>\n<p>用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\n</code></pre>\n<p>虽然使用<code>any</code>也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是<code>number</code>，我们所知的只是返回值可能是任意类型。</p>\n<p>使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 <em>类型变量</em>: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。</p>\n<p>这样在恒等函数里输入的参数类型为<code>number</code>，返回值类型便为<code>number</code>，参数类型为<code>string</code>，返回值类型便为<code>string</code>。</p>\n<h3>泛型类型</h3>\n<p>下面会展示函数自身的类型和如何创建泛型接口（generic interface）。</p>\n<p>泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: &#x3C;Type>(arg: Type) => Type = identity\n</code></pre>\n<p>或者已对象字面量类型：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { &#x3C;Input>(arg: Input): Input } = identity\n</code></pre>\n<p>接下来根据上面示例写第一个泛型接口：</p>\n<pre><code class=\"language-ts\">interface GenericIdentityFn {\r\n  &#x3C;Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn&#x3C;number> = identity  // 指定类型\n</code></pre>\n<h3>泛型类</h3>\n<p>泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (&#x3C;>) 中有一个泛型类型参数列表。</p>\n<pre><code class=\"language-ts\">class GenericNumber&#x3C;NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber&#x3C;number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\n</code></pre>\n<h3>泛型约束</h3>\n<pre><code class=\"language-ts\">function loggingIdentity&#x3C;Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\n</code></pre>\n<p>在上面的例子中，我们想获取arg的<code>length</code>属性，但编译器认为不是所有的类型都有<code>length</code>属性，所以警告我们不能做出这个假设。</p>\n<p>我们不想使用任何类型，而是希望将此函数限制为使用具有<code>length</code>属性的属性。可以使用<code>interface</code>接口和<code>extends</code>关键字来表示约束。</p>\n<pre><code class=\"language-ts\">interface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity&#x3C;Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\n</code></pre>\n<h3>在泛型约束中使用类型参数</h3>\n<p>你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在<code>obj</code>上不存在属性，所以在这两个类型间放置一个约束：</p>\n<pre><code class=\"language-ts\">function getProperty&#x3C;Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\n</code></pre>\n<h3>在泛型中使用Class类型</h3>\n<p>在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:</p>\n<pre><code class=\"language-ts\">function create&#x3C;Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\n</code></pre>\n<p>使用原型属性来推断和约束构造函数和类类型的实例之间的关系。</p>\n<pre><code class=\"language-ts\">class BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance&#x3C;A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\n</code></pre>\n<h2><code>keyof</code> 类型操作符</h2>\n<p><code>keyof</code> 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。</p>\n<pre><code class=\"language-ts\">type Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\n</code></pre>\n<p>上面例子中，<code>M</code>是<code>string | number</code>，这是因为JavaScript对象的键总是会被转成一个字符串，所以<code>obj[0]</code>与<code>obj['0']</code>是一样的。</p>\n<p>当与映射类型结合使用时，keyof 类型变得特别有用。</p>\n<h2><code>typeof</code>类型操作符</h2>"
        },
        "_id": "TypeScript类型操作.md",
        "_raw": {
          "sourceFilePath": "TypeScript类型操作.md",
          "sourceFileName": "TypeScript类型操作.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "TypeScript类型操作"
        },
        "type": "Post",
        "url": "/_posts/TypeScript类型操作"
      },
      "documentHash": "1669041084625",
      "hasWarnings": false,
      "documentTypeName": "Post"
    },
    "利用memo和useMemo优化useContext.md": {
      "document": {
        "title": "React中利用memo和useMemo优化useContext值的渲染",
        "date": "2022-08-25T00:00:00.000Z",
        "slug": "using-memo-and-useMemo-to-optimize-useContext-in-React",
        "tags": [
          "React",
          "React Hooks"
        ],
        "category": "Tec",
        "body": {
          "raw": "\r\n## useContext 的重新渲染问题\r\n\r\n在 React 中如果使用`useContext`hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，`AppContext`提供了两个 value: `count`和`price`，两个子组件`CountChild`和`PriceChild`分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。\r\n\r\n而期望的结果是：当 count 刚更新时，只有`CountChild`重新渲染，price 值同理。\r\n\r\n```jsx\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    <AppContext.Provider value={{ count, price }}>\r\n      <div className=\"App\">\r\n        <button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        </button>\r\n\r\n        <button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        </button>\r\n\r\n        <div>count: {count}</div>\r\n        <div>price: {price}</div>\r\n\r\n        <CountChild />\r\n        <PriceChild />\r\n      </div>\r\n    </AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\r\n```\r\n\r\n## 解决方案\r\n\r\nhttps://github.com/facebook/react/issues/15156\r\n\r\n在 React 的该 issue 中，官方提供了三种解决方案：\r\n\r\n1. 分割 context: （官方推荐）\r\n\r\n在上例中，即将`AppContext`分割成`CountContext`和`PriceContext`提供给相应子组件使用。该方案较简单，不再赘述。\r\n\r\n2. 利用`memo`api\r\n\r\n将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。\r\n\r\n```jsx\r\nconst CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return <CountChild count={count} />\r\n}\r\n```\r\n\r\n3. 利用`useMemo` hooks\r\n\r\n一个组件内部使用`useMemo`，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。\r\n\r\n```jsx\r\nconst MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      <div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      </div>\r\n    )\r\n  }, [price])\r\n}\r\n```\r\n\r\n## Full Code\r\n\r\n<iframe src=\"https://stackblitz.com/edit/react-h3dmvb?embed=1&file=src/App.js\" width=\"100%\" height=\"400px\"></iframe>\r\n",
          "html": "<h2>useContext 的重新渲染问题</h2>\n<p>在 React 中如果使用<code>useContext</code>hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，<code>AppContext</code>提供了两个 value: <code>count</code>和<code>price</code>，两个子组件<code>CountChild</code>和<code>PriceChild</code>分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。</p>\n<p>而期望的结果是：当 count 刚更新时，只有<code>CountChild</code>重新渲染，price 值同理。</p>\n<pre><code class=\"language-jsx\">import React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    &#x3C;AppContext.Provider value={{ count, price }}>\r\n      &#x3C;div className=\"App\">\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        &#x3C;/button>\r\n\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        &#x3C;/button>\r\n\r\n        &#x3C;div>count: {count}&#x3C;/div>\r\n        &#x3C;div>price: {price}&#x3C;/div>\r\n\r\n        &#x3C;CountChild />\r\n        &#x3C;PriceChild />\r\n      &#x3C;/div>\r\n    &#x3C;/AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\n</code></pre>\n<h2>解决方案</h2>\n<p>https://github.com/facebook/react/issues/15156</p>\n<p>在 React 的该 issue 中，官方提供了三种解决方案：</p>\n<ol>\n<li>分割 context: （官方推荐）</li>\n</ol>\n<p>在上例中，即将<code>AppContext</code>分割成<code>CountContext</code>和<code>PriceContext</code>提供给相应子组件使用。该方案较简单，不再赘述。</p>\n<ol start=\"2\">\n<li>利用<code>memo</code>api</li>\n</ol>\n<p>将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。</p>\n<pre><code class=\"language-jsx\">const CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return &#x3C;CountChild count={count} />\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>利用<code>useMemo</code> hooks</li>\n</ol>\n<p>一个组件内部使用<code>useMemo</code>，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。</p>\n<pre><code class=\"language-jsx\">const MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      &#x3C;div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      &#x3C;/div>\r\n    )\r\n  }, [price])\r\n}\n</code></pre>\n<h2>Full Code</h2>"
        },
        "_id": "利用memo和useMemo优化useContext.md",
        "_raw": {
          "sourceFilePath": "利用memo和useMemo优化useContext.md",
          "sourceFileName": "利用memo和useMemo优化useContext.md",
          "sourceFileDir": ".",
          "contentType": "markdown",
          "flattenedPath": "利用memo和useMemo优化useContext"
        },
        "type": "Post",
        "url": "/_posts/利用memo和useMemo优化useContext"
      },
      "documentHash": "1669299082048",
      "hasWarnings": false,
      "documentTypeName": "Post"
    }
  }
}
