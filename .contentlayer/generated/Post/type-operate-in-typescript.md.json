{
  "title": "TypeScript类型操作",
  "date": "2022-05-28T00:00:00.000Z",
  "slug": "type-operate-in-typescript",
  "excerpt": "根据TypeScript官方文档学习TS类型操作的笔记。",
  "tags": [
    "TypeScript"
  ],
  "category": "Tech",
  "body": {
    "raw": "\r\nTypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。\r\n\r\n## 泛型\r\n\r\n### Hello World\r\n\r\n用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n```\r\n\r\n虽然使用`any`也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是`number`，我们所知的只是返回值可能是任意类型。\r\n\r\n使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 _类型变量_: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。\r\n\r\n这样在恒等函数里输入的参数类型为`number`，返回值类型便为`number`，参数类型为`string`，返回值类型便为`string`。\r\n\r\n### 泛型类型\r\n\r\n下面会展示函数自身的类型和如何创建泛型接口（generic interface）。\r\n\r\n泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: <Type>(arg: Type) => Type = identity\r\n```\r\n\r\n或者已对象字面量类型：\r\n\r\n```ts\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { <Input>(arg: Input): Input } = identity\r\n```\r\n\r\n接下来根据上面示例写第一个泛型接口：\r\n\r\n```ts\r\ninterface GenericIdentityFn {\r\n  <Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity<Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn<number> = identity  // 指定类型\r\n```\r\n\r\n### 泛型类\r\n\r\n泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (<>) 中有一个泛型类型参数列表。\r\n\r\n```ts\r\nclass GenericNumber<NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber<number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\r\n```\r\n\r\n### 泛型约束\r\n\r\n```ts\r\nfunction loggingIdentity<Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\r\n```\r\n\r\n在上面的例子中，我们想获取arg的`length`属性，但编译器认为不是所有的类型都有`length`属性，所以警告我们不能做出这个假设。\r\n\r\n我们不想使用任何类型，而是希望将此函数限制为使用具有`length`属性的属性。可以使用`interface`接口和`extends`关键字来表示约束。\r\n\r\n```ts\r\ninterface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity<Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\r\n```\r\n\r\n### 在泛型约束中使用类型参数\r\n\r\n你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在`obj`上不存在属性，所以在这两个类型间放置一个约束：\r\n\r\n```ts\r\nfunction getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\r\n```\r\n\r\n### 在泛型中使用Class类型\r\n\r\n在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:\r\n\r\n```ts\r\nfunction create<Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\r\n```\r\n使用原型属性来推断和约束构造函数和类类型的实例之间的关系。\r\n\r\n```ts\r\nclass BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance<A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\r\n```\r\n\r\n## `keyof` 类型操作符\r\n\r\n`keyof` 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。\r\n\r\n```ts\r\ntype Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\r\n```\r\n\r\n上面例子中，`M`是`string | number`，这是因为JavaScript对象的键总是会被转成一个字符串，所以`obj[0]`与`obj['0']`是一样的。\r\n\r\n当与映射类型结合使用时，keyof 类型变得特别有用。\r\n\r\n## `typeof`类型操作符\r\n\r\n",
    "html": "<p>TypeScript的类型系统非常强大，因为它允许用其他类型来表达类型。 这个想法最简单的形式是泛型，我们实际上有各种各样的类型运算符可供使用。也可以用我们已经拥有的值来表示类型。 通过组合各种类型的操作符，我们可以用简洁、可维护的方式表达复杂的操作和值。</p>\n<h2>泛型</h2>\n<h3>Hello World</h3>\n<p>用一个恒等函数来展示泛型，返回输入的任何任何类型的参数。</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\n</code></pre>\n<p>虽然使用<code>any</code>也是可行的，它能接受任何类型的参数，但是在返回时却丢失了类型信息。如果传入的参数是<code>number</code>，我们所知的只是返回值可能是任意类型。</p>\n<p>使用泛型，可以让我们捕捉到参数类型，并用它来表示返回值。这里我们使用了 <em>类型变量</em>: 一种特殊的变量，作用于类型而不是值，变量名称可以为任意。</p>\n<p>这样在恒等函数里输入的参数类型为<code>number</code>，返回值类型便为<code>number</code>，参数类型为<code>string</code>，返回值类型便为<code>string</code>。</p>\n<h3>泛型类型</h3>\n<p>下面会展示函数自身的类型和如何创建泛型接口（generic interface）。</p>\n<p>泛型函数的类型和非泛型函数一样，类型参数在前，类似于函数声明：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: &#x3C;Type>(arg: Type) => Type = identity\n</code></pre>\n<p>或者已对象字面量类型：</p>\n<pre><code class=\"language-ts\">function identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\nlet myIdentity: { &#x3C;Input>(arg: Input): Input } = identity\n</code></pre>\n<p>接下来根据上面示例写第一个泛型接口：</p>\n<pre><code class=\"language-ts\">interface GenericIdentityFn {\r\n  &#x3C;Type>(arg: Type): Type\r\n}\r\n\r\nfunction identity&#x3C;Type>(arg: Type): Type {\r\n  return arg\r\n}\r\n\r\nlet myIdentity: GenericIdentityFn = identity\r\n\r\nlet yourIdentity: GenericIdentityFn&#x3C;number> = identity  // 指定类型\n</code></pre>\n<h3>泛型类</h3>\n<p>泛型类具有与泛型接口相似，泛型类在类名称后面的尖括号 (&#x3C;>) 中有一个泛型类型参数列表。</p>\n<pre><code class=\"language-ts\">class GenericNumber&#x3C;NumType> {\r\n  zeroValue: NumType\r\n  add: (x: NumType, y: NumType) => NumType\r\n}\r\n\r\nlet myGenericNumber = new GenericNumber&#x3C;number>()\r\nmyGenericNumber.zeroValue = 0\r\nmyGenericNumber.add = function(x, y) {\r\n  return x + y\r\n}\n</code></pre>\n<h3>泛型约束</h3>\n<pre><code class=\"language-ts\">function loggingIdentity&#x3C;Type>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  //报错 Property 'length' does not exist on type 'Type'.\r\n  return arg\r\n}\n</code></pre>\n<p>在上面的例子中，我们想获取arg的<code>length</code>属性，但编译器认为不是所有的类型都有<code>length</code>属性，所以警告我们不能做出这个假设。</p>\n<p>我们不想使用任何类型，而是希望将此函数限制为使用具有<code>length</code>属性的属性。可以使用<code>interface</code>接口和<code>extends</code>关键字来表示约束。</p>\n<pre><code class=\"language-ts\">interface Lengthwise {\r\n  length: number\r\n}\r\n\r\nfunction logginIdentity&#x3C;Type extends Lengthwise>(arg: Type): Type {\r\n  console.log(arg.length)\r\n  return arg\r\n}\r\n\r\nloggingIdentity(3)\r\n// 报错，Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.\r\n\r\nloggingIdentity({ length: 10, value: 3 })\n</code></pre>\n<h3>在泛型约束中使用类型参数</h3>\n<p>你可以声明受另一个类型参数约束的类型参数。比如：我们想从一个对象中获取指定名称的属性，并确保不会抓取到在<code>obj</code>上不存在属性，所以在这两个类型间放置一个约束：</p>\n<pre><code class=\"language-ts\">function getProperty&#x3C;Type, Key extends keyof Type>(obj: Type, key: Key) {\r\n  return obj[key]\r\n}\r\nlet x = { a: 1, b: 2, c: 3 }\r\ngetProperty(x, 'a')   // 1\r\ngetProperty(x, 'm')   // 报错，Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\".\n</code></pre>\n<h3>在泛型中使用Class类型</h3>\n<p>在 TypeScript 中使用泛型创建工厂时，需要通过其构造函数引用类类型。例如:</p>\n<pre><code class=\"language-ts\">function create&#x3C;Type>(c: { new (): Type }): Type {\r\n  return new c()\r\n}\n</code></pre>\n<p>使用原型属性来推断和约束构造函数和类类型的实例之间的关系。</p>\n<pre><code class=\"language-ts\">class BeeKeeper {\r\n  hasMask: boolean = true\r\n}\r\n \r\nclass ZooKeeper {\r\n  nametag: string = \"Mikle\"\r\n}\r\n \r\nclass Animal {\r\n  numLegs: number = 4\r\n}\r\n \r\nclass Bee extends Animal {\r\n  keeper: BeeKeeper = new BeeKeeper()\r\n}\r\n \r\nclass Lion extends Animal {\r\n  keeper: ZooKeeper = new ZooKeeper()\r\n}\r\n \r\nfunction createInstance&#x3C;A extends Animal>(c: new () => A): A {\r\n  return new c()\r\n}\r\n \r\ncreateInstance(Lion).keeper.nametag\r\ncreateInstance(Bee).keeper.hasMask\n</code></pre>\n<h2><code>keyof</code> 类型操作符</h2>\n<p><code>keyof</code> 操作符接收一个对象类型中，并产生根据其键（key）的字符串或数字\r\n的联合（union）类型。</p>\n<pre><code class=\"language-ts\">type Point = { x: number, y: number }\r\ntype P = keyof Point  \r\n// type P = 'x' | 'y'\r\n\r\ntype Arrayish = { [n: number]: unknown }\r\ntype A = keyof Arrayish\r\n// type A = number\r\n\r\ntype Mapish = { [k: string]: boolean }\r\ntype M = keyof Mapish\r\n// type M = string | number\n</code></pre>\n<p>上面例子中，<code>M</code>是<code>string | number</code>，这是因为JavaScript对象的键总是会被转成一个字符串，所以<code>obj[0]</code>与<code>obj['0']</code>是一样的。</p>\n<p>当与映射类型结合使用时，keyof 类型变得特别有用。</p>\n<h2><code>typeof</code>类型操作符</h2>"
  },
  "_id": "type-operate-in-typescript.md",
  "_raw": {
    "sourceFilePath": "type-operate-in-typescript.md",
    "sourceFileName": "type-operate-in-typescript.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "type-operate-in-typescript"
  },
  "type": "Post",
  "url": "type-operate-in-typescript"
}