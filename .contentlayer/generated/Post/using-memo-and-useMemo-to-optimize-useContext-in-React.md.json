{
  "title": "React中利用memo和useMemo优化useContext值的渲染",
  "date": "2022-08-25T00:00:00.000Z",
  "slug": "using-memo-and-useMemo-to-optimize-useContext-in-React",
  "tags": [
    "React",
    "React Hooks"
  ],
  "category": "Tec",
  "body": {
    "raw": "\r\n## useContext 的重新渲染问题\r\n\r\n在 React 中如果使用`useContext`hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，`AppContext`提供了两个 value: `count`和`price`，两个子组件`CountChild`和`PriceChild`分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。\r\n\r\n而期望的结果是：当 count 刚更新时，只有`CountChild`重新渲染，price 值同理。\r\n\r\n```jsx\r\nimport React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    <AppContext.Provider value={{ count, price }}>\r\n      <div className=\"App\">\r\n        <button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        </button>\r\n\r\n        <button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        </button>\r\n\r\n        <div>count: {count}</div>\r\n        <div>price: {price}</div>\r\n\r\n        <CountChild />\r\n        <PriceChild />\r\n      </div>\r\n    </AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\r\n```\r\n\r\n## 解决方案\r\n\r\nhttps://github.com/facebook/react/issues/15156\r\n\r\n在 React 的该 issue 中，官方提供了三种解决方案：\r\n\r\n1. 分割 context: （官方推荐）\r\n\r\n在上例中，即将`AppContext`分割成`CountContext`和`PriceContext`提供给相应子组件使用。该方案较简单，不再赘述。\r\n\r\n2. 利用`memo`api\r\n\r\n将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。\r\n\r\n```jsx\r\nconst CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    <div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    </div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return <CountChild count={count} />\r\n}\r\n```\r\n\r\n3. 利用`useMemo` hooks\r\n\r\n一个组件内部使用`useMemo`，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。\r\n\r\n```jsx\r\nconst MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      <div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      </div>\r\n    )\r\n  }, [price])\r\n}\r\n```\r\n\r\n## Full Code\r\n\r\n<iframe src=\"https://stackblitz.com/edit/react-h3dmvb?embed=1&file=src/App.js\" width=\"100%\" height=\"400px\"></iframe>\r\n",
    "html": "<h2>useContext 的重新渲染问题</h2>\n<p>在 React 中如果使用<code>useContext</code>hooks，context 中的每个 value 更新时都会触发内部子组件的重新渲染，即使有的组件并没有依赖更新的数据。如下面的代码所示：在该例子中，<code>AppContext</code>提供了两个 value: <code>count</code>和<code>price</code>，两个子组件<code>CountChild</code>和<code>PriceChild</code>分别独立依赖每个 value。但是单独更新任意一个 value，都会触发两个子组件的重新渲染。</p>\n<p>而期望的结果是：当 count 刚更新时，只有<code>CountChild</code>重新渲染，price 值同理。</p>\n<pre><code class=\"language-jsx\">import React, {\r\n  createContext,\r\n  useContext,\r\n  memo,\r\n  useState,\r\n  useMemo\r\n} from 'react'\r\n\r\nlet renderIndex = 0\r\nconst AppContext = createContext({})\r\n\r\nconst CountChild = ({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nconst PriceChild = () => {\r\n  console.log('price child render')\r\n  const { price } = useContext(AppContext)\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child price: {price}\r\n    &#x3C;/div>\r\n  )\r\n}\r\n\r\nfunction App() {\r\n  renderIndex++\r\n  console.log(`renderIndex: ${renderIndex}`)\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [price, setPrice] = useState(1)\r\n  return (\r\n    &#x3C;AppContext.Provider value={{ count, price }}>\r\n      &#x3C;div className=\"App\">\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setCount(count + 1)\r\n          }}>\r\n          add count\r\n        &#x3C;/button>\r\n\r\n        &#x3C;button\r\n          onClick={() => {\r\n            setPrice(price + 1)\r\n          }}>\r\n          add price\r\n        &#x3C;/button>\r\n\r\n        &#x3C;div>count: {count}&#x3C;/div>\r\n        &#x3C;div>price: {price}&#x3C;/div>\r\n\r\n        &#x3C;CountChild />\r\n        &#x3C;PriceChild />\r\n      &#x3C;/div>\r\n    &#x3C;/AppContext.Provider>\r\n  )\r\n}\r\n\r\nexport default App\n</code></pre>\n<h2>解决方案</h2>\n<p>https://github.com/facebook/react/issues/15156</p>\n<p>在 React 的该 issue 中，官方提供了三种解决方案：</p>\n<ol>\n<li>分割 context: （官方推荐）</li>\n</ol>\n<p>在上例中，即将<code>AppContext</code>分割成<code>CountContext</code>和<code>PriceContext</code>提供给相应子组件使用。该方案较简单，不再赘述。</p>\n<ol start=\"2\">\n<li>利用<code>memo</code>api</li>\n</ol>\n<p>将子组件成两部分，给内部的组件传入一个指定的 props，外部组件仍然会渲染，但是内部组件不会，因此也不会产生太大开销。</p>\n<pre><code class=\"language-jsx\">const CountChild = memo(({ count }) => {\r\n  console.log('count child render')\r\n\r\n  return (\r\n    &#x3C;div style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n      child count: {count}\r\n    &#x3C;/div>\r\n  )\r\n})\r\n\r\nconst MemoCountChild = () => {\r\n  const { count } = useContext(AppContext)\r\n  return &#x3C;CountChild count={count} />\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>利用<code>useMemo</code> hooks</li>\n</ol>\n<p>一个组件内部使用<code>useMemo</code>，并指定它的依赖，组件仍会被重新执行，但是如果依赖的值没有更新的话，子组件并不会重新渲染。</p>\n<pre><code class=\"language-jsx\">const MemoPriceChild = () => {\r\n  const { price } = useContext(AppContext)\r\n\r\n  return useMemo(() => {\r\n    console.log('price child render')\r\n    return (\r\n      &#x3C;div\r\n        style={{ width: '100px', height: '100px', border: '1px solid black' }}>\r\n        child price: {price}\r\n      &#x3C;/div>\r\n    )\r\n  }, [price])\r\n}\n</code></pre>\n<h2>Full Code</h2>"
  },
  "_id": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
  "_raw": {
    "sourceFilePath": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
    "sourceFileName": "using-memo-and-useMemo-to-optimize-useContext-in-React.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "using-memo-and-useMemo-to-optimize-useContext-in-React"
  },
  "type": "Post",
  "url": "using-memo-and-useMemo-to-optimize-useContext-in-React"
}